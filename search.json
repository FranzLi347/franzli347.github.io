[{"title":"docker-compose + shell 一键化项目部署的一次尝试","url":"/2023/04/05/docker-compose-shell-一键化项目部署的一次尝试/","content":"\n## 业务场景\n\n某项目存在以下架构\n\n![image-20230405171010054](https://blog.frzli.top/2023/04/05/docker-compose-shell-%E4%B8%80%E9%94%AE%E5%8C%96%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95/image-20230405171010054.png)\n\n\n\n\n\n现在需要一键部署自己添加插件编译的 openresty 添加lua脚本以及部署一个基于java的后端服务,并且实现对于java的后端服务实现实时更新的功能，并且通过 Docker Network实现容器之间的相互连接。(如果需要在一键部署中增加redis以及MySQL等等服务也是同理)\n\n  \n\n## 前置知识\n\n### docker-compose\n\n> Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。\n\n通过docker-compose 可以实现创建多个容器并且控制他们的配置和他们之间的关系，本文将通过docker-compose + shell脚本实现一键化部署。\n\n\n### Docker Network\n\n在Docker中，默认情况下容器与容器、容器与外部宿主机的网络是隔离开来的。安装Docker的时候，docker会创建一个桥接器`docker0`，通过它才让容器与容器之间、与宿主机之间通信。\n\n建议使用自定义的网桥来控制哪些容器可以相互通信，可以通过容器名来实现ip的解析。\n\n在docker-compose.yml中添加以下配置实现创建自定义网桥并且实现容器加入网桥\n\n```yaml\nversion: '3'\nservices:\n  web: \n    ...\n    container_name: oss-application\n    ...\n    networks:\n      - oss-networks\n  openresty: \n  \t....\n    container_name: oss-openresty\n    ....\n    networks:\n      - oss-networks\nnetworks:\n  oss-networks:\n    driver: bridge\n```\n\n\n\n## 编写Openresty的Dockerfile\n\n### 因为要自己重新编译一遍 故base image使用 ubuntu:22.04\n\n```dockerfile\nFROM ubuntu:22.04\n```\n\n### 给docker容器里的apt换源并且安装Openresty运行与编译所需要的相关依赖\n\n```dockerfile\n# 换源\nRUN rm /etc/apt/sources.list && \\\n    touch /etc/apt/sources.list && \\\n    echo \"deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse\" >> /etc/apt/sources.list && \\\n    echo \"deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse\" >> /etc/apt/sources.list && \\\n    echo \"deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse\" >> /etc/apt/sources.list && \\\n    echo \"deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse\" >> /etc/apt/sources.list && \\\n    apt-get clean all\n\n\n# 安装相关依赖\nRUN apt-get update && \\\n    apt-get install -y build-essential libpcre3-dev zlib1g-dev libssl-dev git wget perl curl libxml2 libxml2-dev libxslt-dev\n```\n\n### 编译Openresty 并添加需要的模块\n\n```dockerfile\n# openresty源码并解压\nCOPY ./source/openresty-1.21.4.1.tar.gz /\nRUN cd / && \\\n    tar -xzvf openresty-1.21.4.1.tar.gz && \\\n    cd openresty-1.21.4.1/\n\n# ngx_http_dav_module模块\nCOPY ./source/nginx-dav-ext-module-3.0.0.tar.gz /openresty-1.21.4.1/\nRUN cd /openresty-1.21.4.1 && \\\n    tar -xzvf nginx-dav-ext-module-3.0.0.tar.gz && \\\n    mv nginx-dav-ext-module-3.0.0 nginx-dav-ext-module\n\n\n# 配置并编译openresty\nRUN cd /openresty-1.21.4.1 && \\\n    ./configure --prefix=/usr/local/openresty \\\n    --with-http_dav_module \\\n    --add-module=nginx-dav-ext-module \\\n    --without-http_gzip_module && \\\n    make && \\\n    make install\n```\n\n这里添加的是http_dav_module以及nginx-dav-ext-module模块，可以根据自己的需求定制\n\n### 配置Openresty 相关内容\n\n```dockerfile\n# 拷贝配置文件和lua脚本\nRUN rm -rf /usr/local/openresty/nginx/conf/nginx.conf && \\\n    mkdir -p /usr/local/openresty/nginx/lua && \\\n    mkdir -p /toss/tmp\n\nCOPY ./nginx.conf /usr/local/openresty/nginx/conf/\nCOPY ./lua/referer_and_down_auth.lua /usr/local/openresty/nginx/lua/\nCOPY ./lua/webdav_auth.lua /usr/local/openresty/nginx/lua/\nEXPOSE 80\n```\n\n 这里可以拷贝一些自己要运行的脚本和nginx的配置文件，后面通过路径映射配置也是可以的\n\n### 运行openresty\n\n```dockerfile\n# 运行openresty\nCMD [\"/usr/local/openresty/bin/openresty\", \"-g\", \"daemon off;\"]\n```\n\n### 完成Dockerfile\n\n```dockerfile\nFROM ubuntu:22.04\n\n\n# 换源\nRUN rm /etc/apt/sources.list && \\\n    touch /etc/apt/sources.list && \\\n    echo \"deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse\" >> /etc/apt/sources.list && \\\n    echo \"deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse\" >> /etc/apt/sources.list && \\\n    echo \"deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse\" >> /etc/apt/sources.list && \\\n    echo \"deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse\" >> /etc/apt/sources.list && \\\n    apt-get clean all\n\n\n# 安装相关依赖\nRUN apt-get update && \\\n    apt-get install -y build-essential libpcre3-dev zlib1g-dev libssl-dev git wget perl curl libxml2 libxml2-dev libxslt-dev\n\n# openresty源码并解压\nCOPY ./source/openresty-1.21.4.1.tar.gz /\nRUN cd / && \\\n    tar -xzvf openresty-1.21.4.1.tar.gz && \\\n    cd openresty-1.21.4.1/\n\n# ngx_http_dav_module模块\nCOPY ./source/nginx-dav-ext-module-3.0.0.tar.gz /openresty-1.21.4.1/\nRUN cd /openresty-1.21.4.1 && \\\n    tar -xzvf nginx-dav-ext-module-3.0.0.tar.gz && \\\n    mv nginx-dav-ext-module-3.0.0 nginx-dav-ext-module\n\n\n# 配置并编译openresty\nRUN cd /openresty-1.21.4.1 && \\\n    ./configure --prefix=/usr/local/openresty \\\n    --with-http_dav_module \\\n    --add-module=nginx-dav-ext-module \\\n    --without-http_gzip_module && \\\n    make && \\\n    make install\n\n\n# 拷贝配置文件和lua脚本\nRUN rm -rf /usr/local/openresty/nginx/conf/nginx.conf && \\\n    mkdir -p /usr/local/openresty/nginx/lua && \\\n    mkdir -p /toss/tmp\n\n\nCOPY ./nginx.conf /usr/local/openresty/nginx/conf/\nCOPY ./lua/referer_and_down_auth.lua /usr/local/openresty/nginx/lua/\nCOPY ./lua/webdav_auth.lua /usr/local/openresty/nginx/lua/\nEXPOSE 80\n\n# 运行openresty\nCMD [\"/usr/local/openresty/bin/openresty\", \"-g\", \"daemon off;\"]\n\n```\n\n## 编写java应用后端的Dockerfile\n\n这一部分网上很多相似的配置文件没什么好说的\n\n```java\n# java 环境\nFROM openjdk:17-jdk-slim\n# 定义工作目录\nWORKDIR /\n# 把项目中的所有东西复制到工作目录(app)下面 (这里可以改成自己的jar包)\nCOPY ./f-oss-0.0.1-SNAPSHOT.jar /\n# 改变容器的时区\nRUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\nRUN echo 'Asia/Shanghai' >/etc/timezone\n#端口号 （这里可以改成自己的运行命令）\nENTRYPOINT [\"java\",\"-jar\",\"/f-oss-0.0.1-SNAPSHOT.jar\",\"--spring.profiles.active=pro\"]\n```\n\n## 通过docker-compose.yml部署\n\n```yml\nversion: '3'\nservices:\n  web: \n    restart: always\n    build: ./application\n    container_name: oss-application\n    dns:\n      - 223.5.5.5\n      - 223.6.6.6\n    volumes:\n      - /toss:/toss:rw\n    networks:\n      - oss-networks\n  openresty: \n    restart: always\n    build: ./openresty\n    # image: openresty-dav:0.1\n    ports:\n      - 12345:80\n    container_name: oss-openresty\n    dns:\n      - 223.5.5.5\n      - 223.6.6.6\n    volumes:\n      - /toss:/toss:rw\n    networks:\n      - oss-networks\nnetworks:\n  oss-networks:\n    driver: bridge\n\n```\n\n目录结构\n\n> │  docker-compose.yml\n> │  install.sh\n> │\n> ├─application\n> │      Dockerfile\n> │      f-oss-0.0.1-SNAPSHOT.jar\n> │\n> └─openresty\n>     │  Dockerfile\n>     │  nginx.conf\n>     │\n>     ├─lua\n>     │      referer_and_down_auth.lua\n>     │      webdav_auth.lua\n>     │\n>     └─source\n>             nginx-dav-ext-module-3.0.0.tar.gz\n>             openresty-1.21.4.1.tar.gz\n\n\n\n在上面的 docker-compose 中将会自动从两个dockerfile中构建docker image，运行，实现目录挂载，端口映射，加入网桥等等操作\n\n通过运行 `docker-compose up`可以看到两个docker container已经被成功拉起\n\n\n\n![image-20230405173539481](https://blog.frzli.top/2023/04/05/docker-compose-shell-%E4%B8%80%E9%94%AE%E5%8C%96%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95/image-20230405173539481.png)\n\n![image-20230405173548489](https://blog.frzli.top/2023/04/05/docker-compose-shell-%E4%B8%80%E9%94%AE%E5%8C%96%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95/image-20230405173548489.png)\n\n\n\n## shell 脚本的引入\n\n通过上面的部署发现当java后端应用更新之后要手动更新重新构建之后的f-oss-0.0.1-SNAPSHOT.jar，从而实现容器中的应用更新。\n\n我们可以通过实现shell脚本实现每次启动时检查更新，并且自动替换f-oss-0.0.1-SNAPSHOT.jar，重新构建镜像\n\n```shell\n#!/bin/bash\n\n# Check if Docker Compose is installed\nif ! [ -x \"$(command -v docker-compose)\" ]; then\n  echo 'Error: docker-compose is not installed.' >&2\n  exit 1\nfi\n\n# Check if wget is installed\nif ! [ -x \"$(command -v wget)\" ]; then\n  echo 'Error: wget is not installed.' >&2\n  exit 1\nfi\n\n\nif 检查更新逻辑 then\n\t下载最新版 f-oss-0.0.1-SNAPSHOT.jar\n\tdocker-compose build (你的service name)\n fi\n\n# 拉起容器\ndocker-compose up -d\n```\n\n\n\n","tags":["运维","docker","docker-compose"]},{"title":"一次线上事故的反思-MySQL中order by与limit一起使用的坑","url":"/2023/03/29/一次线上事故的反思-MySQL中order-by与limit一起使用的坑/","content":"\n\n## 问题场景\n\n一个新项目提供了一个查询所有Bucket的接口，同时使用了Order By 和 limit 同时进行排序和分页查询\n\n```sql\nSELECT\n\t* \nFROM\n\ttb_bucket \nWHERE\n\tuid = ${userId} \nORDER BY\n\tcreate_time DESC \n    limit ${(page - 1)*size}, #{size}\n```\n\n\n\n上线后前端反馈数据出现来回跳动，数据一会出现在第一页一会出现在第二页，导致数据一部分缺失一部分重复\n\n![image-20230329092527083](https://blog.frzli.top/2023/03/29/%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85%E7%9A%84%E5%8F%8D%E6%80%9D-MySQL%E4%B8%ADorder-by%E4%B8%8Elimit%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91/image-20230329092527083.png)\n\n![image-20230329092538575](https://blog.frzli.top/2023/03/29/%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85%E7%9A%84%E5%8F%8D%E6%80%9D-MySQL%E4%B8%ADorder-by%E4%B8%8Elimit%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91/image-20230329092538575.png)\n\n## 问题分析\n\n发生问题后首先检查了一遍代码逻辑，并未发现其他问题，当把SQL拿出来单独执行的时候出现了数据错误的问题。发现出现数据错误的数据都有相同的create_time，而SQL又是基于create_time排序的，故怀疑order by 和 limit 同时使用的问题。**以create_time进行降序排序，当create_time存在多条重复时基于limit分页出现数据错误问题。**\n\n\n\n查阅了MySQL的官方文档发现的MySQL limit的查询优化所导致\n\n> If multiple rows have identical values in the `ORDER BY` columns, the server is free to return those rows in any order, and may do so differently depending on the overall execution plan. In other words, the sort order of those rows is nondeterministic with respect to the nonordered columns\n\n大意就是**如果多个行在“ORDER BY”列中具有相同的值，服务器可以自由地以任何顺序返回这些行，并且可能会根据整体执行计划以不同的方式返回。换句话说，这些行的排序顺序相对于未排序的列是不确定的**。\n\n[MySQL 官方文档原文](https://dev.mysql.com/doc/refman/8.0/en/limit-optimization.html)\n\n## 问题解决\n\n解决思路是：避免ORDER BY列的值出现重复。因此，可以加入排序列，比如id等等。\n\n```sql\nSELECT\n\t* \nFROM\n\ttb_bucket \nWHERE\n\tuid = ${userId} \nORDER BY\n\tcreate_time DESC id ASC\n    limit ${(page - 1)*size}, #{size}\n```\n\n加入id作为排序条件后，数据混乱的问题解决\n\n![image-20230329142622876](https://blog.frzli.top/2023/03/29/%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85%E7%9A%84%E5%8F%8D%E6%80%9D-MySQL%E4%B8%ADorder-by%E4%B8%8Elimit%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91/image-20230329142622876.png)\n\n![image-20230329142652385](https://blog.frzli.top/2023/03/29/%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85%E7%9A%84%E5%8F%8D%E6%80%9D-MySQL%E4%B8%ADorder-by%E4%B8%8Elimit%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91/image-20230329142652385.png)\n","tags":["后端","MySQL"]},{"title":"Openresty 实现 WebDAV 功能 ，并且实现在 WebDAV 下多用户认证以及访问目录控制","url":"/2023/03/25/Openresty-实现-WebDAV-功能-，并且实现在-WebDAV-下多用户认证以及访问目录控制/","content":"\n\n## 0.介绍\n\n> 基于Web的分布式编写和版本控制（WebDAV）是超文本传输协议（HTTP）的扩展，有利于用户间协同编辑和管理存储在万维网服务器文档。WebDAV由互联网工程任务组的工作组在RFC 4918中定义。\n> WebDAV协议为用户在服务器上创建、更改和移动文档提供了一个框架。WebDAV协议最重要的功能包括维护作者或修改日期的属性、名字空间管理、集合和覆盖保护。维护属性包括创建、删除和查询文件信息等。名字空间管理处理在服务器名称空间内复制和移动网页的能力。集合（Collections）处理各种资源的创建、删除和列举 (from wikipedia)  [wikipedia](https://zh.wikipedia.org/zh-cn/%E5%9F%BA%E4%BA%8EWeb%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E5%86%99%E5%92%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6) \n\nnginx 中的 [ngx_http_dav_module](http://nginx.org/en/docs/http/ngx_http_dav_module.html) 模块提供了该功能的支持，[nginx-dav-ext-module](https://github.com/arut/nginx-dav-ext-module) 主要是实现了 NGINX WebDAV 未实现的命令支持，包括：PROPFIND & OPTIONS 对于完整的 WebDAV 支持\n\n通过 windows 自带的网络驱动器映射可以实现以下效果\n\n![image-20230325204817756](https://blog.frzli.top/2023/03/25/Openresty-%E5%AE%9E%E7%8E%B0-WebDAV-%E5%8A%9F%E8%83%BD-%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E5%9C%A8-WebDAV-%E4%B8%8B%E5%A4%9A%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E4%BB%A5%E5%8F%8A%E8%AE%BF%E9%97%AE%E7%9B%AE%E5%BD%95%E6%8E%A7%E5%88%B6/image-20230325204817756.png)\n\n## 1.Openresty 的编译与安装\n\nOpenResty 是一个基于 Nginx 的 Web 平台，整合了诸如 LuaJIT、LuaNginxModule 等模块,所以我们用 Openresty 代替 nginx\n\n因为webdav需要 ngx_http_dav_module 以及 nginx-dav-ext-module 的支持 ，所以我们要自己编译自己的Openresty \n\n**环境 Ubuntu 22.04**\n\n### 1.1 Openresty 源代码下载\n\n通过 [Openresty 官方网站](https://openresty.org/cn/download.html)获取最新的源代码并且解压\n\n```bash\nwget https://openresty.org/download/openresty-1.21.4.1.tar.gz\ntar -xzvf openresty-1.21.4.1.tar.gz\n```\n\n### 1.2 开发依赖安装\n\n```bash\napt-get update\n\napt-get install libpcre3-dev \\\n    libssl-dev perl make build-essential curl \\\n    libxml2 libxml2-dev libxslt-dev\n```\n\n### 1.3 下载 nginx-dav-ext-module 并且配置编译时所添加的module\n\n```bash\ncd openresty-1.21.4.1\n\nwget https://codeload.github.com/arut/nginx-dav-ext-module/tar.gz/refs/tags/v3.0.0 -O nginx-dav-ext-module.tar.gz\n\ntar -xzvf nginx-dav-ext-module.tar.gz\n\n./configure --prefix=/usr/local/openresty \\\n            --with-http_dav_module \\\n            --add-module=nginx-dav-ext-module \\\n            --without-http_gzip_module \n```\n\n### 1.4 编译并且安装 \n\n```bash\ngmake\n\ngmake install \n```\n\n执行上述命令后会发现 Openresty 已经安装在 /usr/local/openresty 但是 openresty 命令还是不可用,可以通过添加软连接实现可以在任意文件夹使用 openresty 命令\n\n```bash\ncd /usr/local/openresty/bin\n\nsudo ln -s `pwd`/openresty /usr/local/bin/openresty\nsudo ln -s `pwd`/opm /usr/local/bin/opm\n```\n\n\n\n运行 Openresty 访问 http://localhost 将会出现 Welcome to OpenResty! 字样，代表 OpenResty 已经安装成功!\n\n\n\n![image-20230325205506326](https://blog.frzli.top/2023/03/25/Openresty-%E5%AE%9E%E7%8E%B0-WebDAV-%E5%8A%9F%E8%83%BD-%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E5%9C%A8-WebDAV-%E4%B8%8B%E5%A4%9A%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E4%BB%A5%E5%8F%8A%E8%AE%BF%E9%97%AE%E7%9B%AE%E5%BD%95%E6%8E%A7%E5%88%B6/image-20230325205506326.png)\n\n## 2. 最简单的 Webdav 实现 \n\n修改配置文件 `/usr/local/openresty/nginx/conf/nginx.conf`\n\n```HOCON\nhttp {\n\t... # 你自己的某些配置\n \n    server {\n        ...\n \n        location / {\n        \t# webdav 访问的根目录 ，暂时使用root \n            root /www/wwwroot/webdav; \n    \t\t# 文件暂存地址\n            client_body_temp_path /www/wwwroot/webdav/client_temp; \n \t\t\t# webdav 支持的方法\n            dav_methods PUT DELETE MKCOL COPY MOVE;\n            dav_ext_methods PROPFIND OPTIONS LOCK UNLOCK;\n            \n            create_full_put_path on;\n            dav_access\t\tuser:rw group:rw  all:r;\n \t\t\t# 网页页面自动索引文件\n            autoindex on;\n        }\n    }\n}\n```\n\n这样可以实现最基本的无认证，无动态目录WebDAV \n\n\n\n这篇我们编译了带实现 webdav module支持的openresy ，并且实现了最简单的WebDAV，下一篇将会通过编写lua脚本实现多用户认证，以及动态控制访问目录的功能（应该会很快写出来）\n\n\n\n\n\n","tags":["webdav","Openresty","后端","lua"]},{"title":"基础算法-二分答案","url":"/2023/03/21/基础算法-二分答案/","content":"\n## 二分答案： \n\n>解题的时候往往会考虑枚举答案然后检验枚举的值是否正确。若满足单调性，则满足使用二分法的条件。把这里的枚举换成二分，就变成了「二分答案」。[OI-WIKI](https://oi-wiki.org/basic/binary/#%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88)\n\n## 二分答案模板\n\n### 寻找 >= 的最小值\n\n```java\n    int bserach_l(int l, int r, int x)\n    {\n        while (l < r) {\n            int mid = l + ((r - l) >> 1); // 防止溢出\n            if (check(mid))\n                r = mid;\n            else\n                l = mid + 1;\n        }\n        return l;\n    }\n```\n\n### 寻找 <= 的模板\n\n```java\n    int bserach_l(int l, int r, int x)\n    {\n        while (l < r) {\n            int mid = l + ((r - l) >> 1) + 1; // 防止溢出\n            if (check(mid))\n                r = mid;\n            else\n                l = mid - 1;\n        }\n        return l;\n    }\n```\n\n### 例题 \n\n例题 [P2440 木材加工](https://www.luogu.com.cn/problem/P2440)\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        int n,k;\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        k = sc.nextInt();\n        int max = 0;\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n            max = Math.max(max,arr[i]);\n        }\n        int l = 1 , r = max;\n        int val = 0;\n        int maxVal = 0;\n        int res = 0;\n        while(l <  r){\n            int mid = l + ((r - l) >> 1);\n            val = getChunkNums(arr,mid);\n            if (val < k){\n                r = mid;\n            }else{\n                l = mid + 1;\n                if (mid >= res){\n                    res = mid;\n                    maxVal = val;\n                }\n            }\n\n        }\n        System.out.println(maxVal >= k ? res : 0);\n    }\n\n    public static int getChunkNums(int[] arr,int l){\n        int res = 0;\n        for (int i1 = 0; i1 < arr.length; i1++) {\n            res += arr[i1] / l;\n        }\n        return res;\n    }\n}\n```\n\n","tags":["算法"]},{"title":"go学习笔记和一些语法糖","url":"/2023/03/21/go学习笔记/","content":"\n\n\n### ... 的用法\n\n#### 可变参数\n\n```go\nfunc a(args ...int) int {\n\tfor _, val := range args {\n\t\t// do something\n\t}\n}\n```\n\n#### 打散slice\n\n```go\nfunc a() {\n\ts := []int{1, 2, 3}\n    b(s...)  // 这里的slice {1，2，3} 被打散为 1，2，3 传入函数b\n}\n\nfunc b(args2 ...int) {\n\tfor _, i := range args2 {\n\t\t// do something\n\t}\n}\n```\n\n### go中的继承\n\n先看一段代码\n\n```go\ntype (\n\tRouterGroup struct {\n\t\tprefix      string\n\t\tmiddlewares []HandlerFunc\n\t\tparent      *RouterGroup\n\t\tengine      *Engine\n\t}\n\n\tEngine struct {\n\t\t*RouterGroup\n\t\trouter *router\n\t\tgroups []*RouterGroup\n\t}\n)\n```\n\n可以看到上面`Engine`中包含了`*RouterGroup`这一匿名字段，`Engine` 结构体将直接继承 `RouterGroup` 中的所有字段和方法，并且不需要使用 `.prefix`、`.middlewares`、`.parent` 等字段来引用 `RouterGroup` 中的属性和方法，而可以直接使用 `Engine` 实例进行访问。\n\n### go tag\n\ntag 是一种结构化的注释方式，它可以用于给结构体字段添加元数据，例如字段的名称、类型、格式、验证规则等信息。\n\n示例如下\n\n```go\ntype Person struct {\n    Name string `json:\"name\" xml:\"name\"`\n    Age  int    `json:\"age\" xml:\"age\"`\n}\n```\n\n可以最终通过反射拿到tag的k-v信息\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\ntype Person struct {\n    Name string `json:\"name\" xml:\"name\"`\n    Age  int    `json:\"age\" xml:\"age\"`\n}\n\nfunc main() {\n    p := Person{Name: \"Alice\", Age: 25}\n    t := reflect.TypeOf(p)\n    for i := 0; i < t.NumField(); i++ {\n        field := t.Field(i)\n        tag := field.Tag\n        fmt.Printf(\"Field: %s, JSON tag: %s, XML tag: %s\\n\",\n            field.Name, tag.Get(\"json\"), tag.Get(\"xml\"))\n    }\n}\n```\n\n### cap和len\n\n`cap` 和 `len` 都是内置函数，用于获取切片、数组、map 和 channel 的长度和容量信息。\n\nslice作为一个array的引用其cap和len并不一定相等，slice的容量可以动态扩展，如果在使用 `append` 函数将元素添加到切片时长度超过了当前容量，Go 会动态分配一块更大的内存作为底层数组，并将原有数据复制到新的内存空间中，完成切片的扩容过程。如果切片的长度没有超过容量，则不会进行扩容。这个过程会导致切片的地址发生变化。可以通过对比改变前后切片的地址来判断是否扩容。\n\n### any\n\n在go1.18之后添加的新关键字 [all: rewrite `interface{}` to `any` #49884](https://github.com/golang/go/issues/49884)\n\n等同于之前的interface{} \n\n```go\ntype any interface{}\n```\n\n用法\n\n```go\nfunc a(v any) {\n\tswitch v.(type) {\n\tcase int:\n\t\tfmt.Println(\"int type val\")\n\tcase bool:\n\t\tfmt.Println(\"bool type val\")\n\t}\n}\n```\n\n","tags":["后端","go"]},{"title":"SpringBoot创建自己的Start","url":"/2023/03/05/SpringBoot创建自己的Starter/","content":"\n1. 创建SpringBoot项目\n\n   包含以下依赖\n\n```xml\n \t\t<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n\n\t     <!--自动生成meta-data-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-configuration-processor</artifactId>\n            <optional>true</optional>\n        </dependency>\n            \n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n```\n\n2. 修改`pom.xml`\n\n   修改pom.xml为对应项目名称 \n\n   starter推荐命名 xxxxx-start\n\n   ```xml\n       <groupId>com.frz</groupId>\n       <artifactId>frzApi-client-sdk</artifactId>\n       <version>0.0.2</version>\n       <name>frzApi-client-sdk</name>\n       <description>frzApi-client-sdk</description>\n   ```\n\n3. 编写`AutoConfiguration`\n\n   ```java\n   @Configuration\n   @ConfigurationProperties(\"frzapi.client\")\n   @Data\n   @ComponentScan\n   public class FrzApiClientConfig {\n       private String accessKey;\n       private String secretKey;\n       @Bean\n       public FrzApiClient frzApiClient(){\n           return new FrzApiClient(accessKey, secretKey);\n       }\n   }\n   ```\n\n   通过`ConfigurationProperties`注解能够读取application 中的配置属性\n\n4. 配置`EnableAutoConfiguration`\n\n   在`resource/META-INF`创建`spring.factories`文件,设置\n\n   ```properties\n   org.springframework.boot.autoconfigure.EnableAutoConfiguration=xxx\n   ```\n\n   > xxx为配置类Reference\n\n![目录结构](im1.png \"目录结构\")\n\n通过maven install 后即成功安装到本地maven仓库\n\n在其他项目的依赖中添加\n\n```xml\n<dependency>\n   <groupId>com.frz</groupId>\n   <artifactId>frzApi-client-sdk</artifactId>\n   <version>0.0.2</version>\n</dependency>\n```\n\n既可以正常使用\n\n\n\n","tags":["后端","sprigboot","java"]}]