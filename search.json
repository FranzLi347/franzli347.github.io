[{"title":"基础算法-二分答案","url":"/2023/03/21/基础算法-二分答案/","content":"\n## 二分答案： \n\n>解题的时候往往会考虑枚举答案然后检验枚举的值是否正确。若满足单调性，则满足使用二分法的条件。把这里的枚举换成二分，就变成了「二分答案」。[OI-WIKI](https://oi-wiki.org/basic/binary/#%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88)\n\n## 二分答案模板\n\n### 寻找 >= 的最小值\n\n```java\n    int bserach_l(int l, int r, int x)\n    {\n        while (l < r) {\n            int mid = l + ((r - l) >> 1); // 防止溢出\n            if (check(mid))\n                r = mid;\n            else\n                l = mid + 1;\n        }\n        return l;\n    }\n```\n\n### 寻找 <= 的模板\n\n```java\n    int bserach_l(int l, int r, int x)\n    {\n        while (l < r) {\n            int mid = l + ((r - l) >> 1) + 1; // 防止溢出\n            if (check(mid))\n                r = mid;\n            else\n                l = mid - 1;\n        }\n        return l;\n    }\n```\n\n### 例题 \n\n例题 [P2440 木材加工](https://www.luogu.com.cn/problem/P2440)\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        int n,k;\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        k = sc.nextInt();\n        int max = 0;\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n            max = Math.max(max,arr[i]);\n        }\n        int l = 1 , r = max;\n        int val = 0;\n        int maxVal = 0;\n        int res = 0;\n        while(l <  r){\n            int mid = l + ((r - l) >> 1);\n            val = getChunkNums(arr,mid);\n            if (val < k){\n                r = mid;\n            }else{\n                l = mid + 1;\n                if (mid >= res){\n                    res = mid;\n                    maxVal = val;\n                }\n            }\n\n        }\n        System.out.println(maxVal >= k ? res : 0);\n    }\n\n    public static int getChunkNums(int[] arr,int l){\n        int res = 0;\n        for (int i1 = 0; i1 < arr.length; i1++) {\n            res += arr[i1] / l;\n        }\n        return res;\n    }\n}\n```\n\n","tags":["算法"]},{"title":"go学习笔记和一些语法糖","url":"/2023/03/21/go学习笔记/","content":"\n\n\n### ... 的用法\n\n#### 可变参数\n\n```go\nfunc a(args ...int) int {\n\tfor _, val := range args {\n\t\t// do something\n\t}\n}\n```\n\n#### 打散slice\n\n```go\nfunc a() {\n\ts := []int{1, 2, 3}\n    b(s...)  // 这里的slice {1，2，3} 被打散为 1，2，3 传入函数b\n}\n\nfunc b(args2 ...int) {\n\tfor _, i := range args2 {\n\t\t// do something\n\t}\n}\n```\n\n### go中的继承\n\n先看一段代码\n\n```go\ntype (\n\tRouterGroup struct {\n\t\tprefix      string\n\t\tmiddlewares []HandlerFunc\n\t\tparent      *RouterGroup\n\t\tengine      *Engine\n\t}\n\n\tEngine struct {\n\t\t*RouterGroup\n\t\trouter *router\n\t\tgroups []*RouterGroup\n\t}\n)\n```\n\n可以看到上面`Engine`中包含了`*RouterGroup`这一匿名字段，`Engine` 结构体将直接继承 `RouterGroup` 中的所有字段和方法，并且不需要使用 `.prefix`、`.middlewares`、`.parent` 等字段来引用 `RouterGroup` 中的属性和方法，而可以直接使用 `Engine` 实例进行访问。\n\n### go tag\n\ntag 是一种结构化的注释方式，它可以用于给结构体字段添加元数据，例如字段的名称、类型、格式、验证规则等信息。\n\n示例如下\n\n```go\ntype Person struct {\n    Name string `json:\"name\" xml:\"name\"`\n    Age  int    `json:\"age\" xml:\"age\"`\n}\n```\n\n可以最终通过反射拿到tag的k-v信息\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\ntype Person struct {\n    Name string `json:\"name\" xml:\"name\"`\n    Age  int    `json:\"age\" xml:\"age\"`\n}\n\nfunc main() {\n    p := Person{Name: \"Alice\", Age: 25}\n    t := reflect.TypeOf(p)\n    for i := 0; i < t.NumField(); i++ {\n        field := t.Field(i)\n        tag := field.Tag\n        fmt.Printf(\"Field: %s, JSON tag: %s, XML tag: %s\\n\",\n            field.Name, tag.Get(\"json\"), tag.Get(\"xml\"))\n    }\n}\n```\n\n### cap和len\n\n`cap` 和 `len` 都是内置函数，用于获取切片、数组、map 和 channel 的长度和容量信息。\n\nslice作为一个array的引用其cap和len并不一定相等，slice的容量可以动态扩展，如果在使用 `append` 函数将元素添加到切片时长度超过了当前容量，Go 会动态分配一块更大的内存作为底层数组，并将原有数据复制到新的内存空间中，完成切片的扩容过程。如果切片的长度没有超过容量，则不会进行扩容。这个过程会导致切片的地址发生变化。可以通过对比改变前后切片的地址来判断是否扩容。\n","tags":["后端","go"]},{"title":"SpringBoot创建自己的Start","url":"/2023/03/05/SpringBoot创建自己的Starter/","content":"\n1. 创建SpringBoot项目\n\n   包含以下依赖\n\n```xml\n \t\t<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n\n\t     <!--自动生成meta-data-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-configuration-processor</artifactId>\n            <optional>true</optional>\n        </dependency>\n            \n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n```\n\n2. 修改`pom.xml`\n\n   修改pom.xml为对应项目名称 \n\n   starter推荐命名 xxxxx-start\n\n   ```xml\n       <groupId>com.frz</groupId>\n       <artifactId>frzApi-client-sdk</artifactId>\n       <version>0.0.2</version>\n       <name>frzApi-client-sdk</name>\n       <description>frzApi-client-sdk</description>\n   ```\n\n3. 编写`AutoConfiguration`\n\n   ```java\n   @Configuration\n   @ConfigurationProperties(\"frzapi.client\")\n   @Data\n   @ComponentScan\n   public class FrzApiClientConfig {\n       private String accessKey;\n       private String secretKey;\n       @Bean\n       public FrzApiClient frzApiClient(){\n           return new FrzApiClient(accessKey, secretKey);\n       }\n   }\n   ```\n\n   通过`ConfigurationProperties`注解能够读取application 中的配置属性\n\n4. 配置`EnableAutoConfiguration`\n\n   在`resource/META-INF`创建`spring.factories`文件,设置\n\n   ```properties\n   org.springframework.boot.autoconfigure.EnableAutoConfiguration=xxx\n   ```\n\n   > xxx为配置类Reference\n\n![目录结构](im1.png \"目录结构\")\n\n通过maven install 后即成功安装到本地maven仓库\n\n在其他项目的依赖中添加\n\n```xml\n<dependency>\n   <groupId>com.frz</groupId>\n   <artifactId>frzApi-client-sdk</artifactId>\n   <version>0.0.2</version>\n</dependency>\n```\n\n既可以正常使用\n\n\n\n","tags":["后端","sprigboot","java"]}]