[{"title":"go学习笔记和一些语法糖","url":"/2023/03/21/go学习笔记/","content":"\n\n\n### ... 的用法\n\n#### 可变参数\n\n```go\nfunc a(args ...int) int {\n\tfor _, val := range args {\n\t\t// do something\n\t}\n}\n```\n\n#### 打散slice\n\n```go\nfunc a() {\n\ts := []int{1, 2, 3}\n    b(s...)  // 这里的slice {1，2，3} 被打散为 1，2，3 传入函数b\n}\n\nfunc b(args2 ...int) {\n\tfor _, i := range args2 {\n\t\t// do something\n\t}\n}\n```\n\n### go中的继承\n\n先看一段代码\n\n```go\ntype (\n\tRouterGroup struct {\n\t\tprefix      string\n\t\tmiddlewares []HandlerFunc\n\t\tparent      *RouterGroup\n\t\tengine      *Engine\n\t}\n\n\tEngine struct {\n\t\t*RouterGroup\n\t\trouter *router\n\t\tgroups []*RouterGroup\n\t}\n)\n```\n\n可以看到上面`Engine`中包含了`*RouterGroup`这一匿名字段，`Engine` 结构体将直接继承 `RouterGroup` 中的所有字段和方法，并且不需要使用 `.prefix`、`.middlewares`、`.parent` 等字段来引用 `RouterGroup` 中的属性和方法，而可以直接使用 `Engine` 实例进行访问。\n\n### go tag\n\ntag 是一种结构化的注释方式，它可以用于给结构体字段添加元数据，例如字段的名称、类型、格式、验证规则等信息。\n\n示例如下\n\n```go\ntype Person struct {\n    Name string `json:\"name\" xml:\"name\"`\n    Age  int    `json:\"age\" xml:\"age\"`\n}\n```\n\n可以最终通过反射拿到tag的k-v信息\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\ntype Person struct {\n    Name string `json:\"name\" xml:\"name\"`\n    Age  int    `json:\"age\" xml:\"age\"`\n}\n\nfunc main() {\n    p := Person{Name: \"Alice\", Age: 25}\n    t := reflect.TypeOf(p)\n    for i := 0; i < t.NumField(); i++ {\n        field := t.Field(i)\n        tag := field.Tag\n        fmt.Printf(\"Field: %s, JSON tag: %s, XML tag: %s\\n\",\n            field.Name, tag.Get(\"json\"), tag.Get(\"xml\"))\n    }\n}\n```\n\n### cap和len\n\n`cap` 和 `len` 都是内置函数，用于获取切片、数组、map 和 channel 的长度和容量信息。\n\nslice作为一个array的引用其cap和len并不一定相等，slice的容量可以动态扩展，如果在使用 `append` 函数将元素添加到切片时长度超过了当前容量，Go 会动态分配一块更大的内存作为底层数组，并将原有数据复制到新的内存空间中，完成切片的扩容过程。如果切片的长度没有超过容量，则不会进行扩容。这个过程会导致切片的地址发生变化。可以通过对比改变前后切片的地址来判断是否扩容。\n","tags":["后端","go"]},{"title":"SpringBoot创建自己的Start","url":"/2023/03/05/SpringBoot创建自己的Starter/","content":"\n1. 创建SpringBoot项目\n\n   包含以下依赖\n\n```xml\n \t\t<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n\n\t     <!--自动生成meta-data-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-configuration-processor</artifactId>\n            <optional>true</optional>\n        </dependency>\n            \n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n```\n\n2. 修改`pom.xml`\n\n   修改pom.xml为对应项目名称 \n\n   starter推荐命名 xxxxx-start\n\n   ```xml\n       <groupId>com.frz</groupId>\n       <artifactId>frzApi-client-sdk</artifactId>\n       <version>0.0.2</version>\n       <name>frzApi-client-sdk</name>\n       <description>frzApi-client-sdk</description>\n   ```\n\n3. 编写`AutoConfiguration`\n\n   ```java\n   @Configuration\n   @ConfigurationProperties(\"frzapi.client\")\n   @Data\n   @ComponentScan\n   public class FrzApiClientConfig {\n       private String accessKey;\n       private String secretKey;\n       @Bean\n       public FrzApiClient frzApiClient(){\n           return new FrzApiClient(accessKey, secretKey);\n       }\n   }\n   ```\n\n   通过`ConfigurationProperties`注解能够读取application 中的配置属性\n\n4. 配置`EnableAutoConfiguration`\n\n   在`resource/META-INF`创建`spring.factories`文件,设置\n\n   ```properties\n   org.springframework.boot.autoconfigure.EnableAutoConfiguration=xxx\n   ```\n\n   > xxx为配置类Reference\n\n![目录结构](im1.png \"目录结构\")\n\n通过maven install 后即成功安装到本地maven仓库\n\n在其他项目的依赖中添加\n\n```xml\n<dependency>\n   <groupId>com.frz</groupId>\n   <artifactId>frzApi-client-sdk</artifactId>\n   <version>0.0.2</version>\n</dependency>\n```\n\n既可以正常使用\n\n\n\n","tags":["后端","sprigboot","java"]}]