[{"title":"Openresty 实现 WebDAV 功能 ，并且实现在 WebDAV 下多用户认证以及访问目录控制","url":"/2023/03/25/Openresty-实现-WebDAV-功能-，并且实现在-WebDAV-下多用户认证以及访问目录控制/","content":"\n\n## 0.介绍\n\n> 基于Web的分布式编写和版本控制（WebDAV）是超文本传输协议（HTTP）的扩展，有利于用户间协同编辑和管理存储在万维网服务器文档。WebDAV由互联网工程任务组的工作组在RFC 4918中定义。\n> WebDAV协议为用户在服务器上创建、更改和移动文档提供了一个框架。WebDAV协议最重要的功能包括维护作者或修改日期的属性、名字空间管理、集合和覆盖保护。维护属性包括创建、删除和查询文件信息等。名字空间管理处理在服务器名称空间内复制和移动网页的能力。集合（Collections）处理各种资源的创建、删除和列举 (from wikipedia)  [wikipedia](https://zh.wikipedia.org/zh-cn/%E5%9F%BA%E4%BA%8EWeb%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E5%86%99%E5%92%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6) \n\nnginx 中的 [ngx_http_dav_module](http://nginx.org/en/docs/http/ngx_http_dav_module.html) 模块提供了该功能的支持，[nginx-dav-ext-module](https://github.com/arut/nginx-dav-ext-module) 主要是实现了 NGINX WebDAV 未实现的命令支持，包括：PROPFIND & OPTIONS 对于完整的 WebDAV 支持\n\n通过 windows 自带的网络驱动器映射可以实现以下效果\n\n![image-20230325204817756](https://blog.frzli.top/2023/03/25/Openresty-%E5%AE%9E%E7%8E%B0-WebDAV-%E5%8A%9F%E8%83%BD-%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E5%9C%A8-WebDAV-%E4%B8%8B%E5%A4%9A%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E4%BB%A5%E5%8F%8A%E8%AE%BF%E9%97%AE%E7%9B%AE%E5%BD%95%E6%8E%A7%E5%88%B6/image-20230325204817756.png)\n\n## 1.Openresty 的编译与安装\n\nOpenResty 是一个基于 Nginx 的 Web 平台，整合了诸如 LuaJIT、LuaNginxModule 等模块,所以我们用 Openresty 代替 nginx\n\n因为webdav需要 ngx_http_dav_module 以及 nginx-dav-ext-module 的支持 ，所以我们要自己编译自己的Openresty \n\n**环境 Ubuntu 22.04**\n\n### 1.1 Openresty 源代码下载\n\n通过 [Openresty 官方网站](https://openresty.org/cn/download.html)获取最新的源代码并且解压\n\n```bash\nwget https://openresty.org/download/openresty-1.21.4.1.tar.gz\ntar -xzvf openresty-1.21.4.1.tar.gz\n```\n\n### 1.2 开发依赖安装\n\n```bash\napt-get update\n\napt-get install libpcre3-dev \\\n    libssl-dev perl make build-essential curl \\\n    libxml2 libxml2-dev libxslt-dev\n```\n\n### 1.3 下载 nginx-dav-ext-module 并且配置编译时所添加的module\n\n```bash\ncd openresty-1.21.4.1\n\nwget https://codeload.github.com/arut/nginx-dav-ext-module/tar.gz/refs/tags/v3.0.0 -O nginx-dav-ext-module.tar.gz\n\ntar -xzvf nginx-dav-ext-module.tar.gz\n\n./configure --prefix=/usr/local/openresty \\\n            --with-http_dav_module \\\n            --add-module=nginx-dav-ext-module \\\n            --without-http_gzip_module \n```\n\n### 1.4 编译并且安装 \n\n```bash\ngmake\n\ngmake install \n```\n\n执行上述命令后会发现 Openresty 已经安装在 /usr/local/openresty 但是 openresty 命令还是不可用,可以通过添加软连接实现可以在任意文件夹使用 openresty 命令\n\n```bash\ncd /usr/local/openresty/bin\n\nsudo ln -s `pwd`/openresty /usr/local/bin/openresty\nsudo ln -s `pwd`/opm /usr/local/bin/opm\n```\n\n\n\n运行 Openresty 访问 http://localhost 将会出现 Welcome to OpenResty! 字样，代表 OpenResty 已经安装成功!\n\n\n\n![image-20230325205506326](https://blog.frzli.top/2023/03/25/Openresty-%E5%AE%9E%E7%8E%B0-WebDAV-%E5%8A%9F%E8%83%BD-%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E5%9C%A8-WebDAV-%E4%B8%8B%E5%A4%9A%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E4%BB%A5%E5%8F%8A%E8%AE%BF%E9%97%AE%E7%9B%AE%E5%BD%95%E6%8E%A7%E5%88%B6/image-20230325205506326.png)\n\n## 2. 最简单的 Webdav 实现 \n\n修改配置文件 `/usr/local/openresty/nginx/conf/nginx.conf`\n\n```HOCON\nhttp {\n\t... # 你自己的某些配置\n \n    server {\n        ...\n \n        location / {\n        \t# webdav 访问的根目录 ，暂时使用root \n            root /www/wwwroot/webdav; \n    \t\t# 文件暂存地址\n            client_body_temp_path /www/wwwroot/webdav/client_temp; \n \t\t\t# webdav 支持的方法\n            dav_methods PUT DELETE MKCOL COPY MOVE;\n            dav_ext_methods PROPFIND OPTIONS LOCK UNLOCK;\n            \n            create_full_put_path on;\n            dav_access\t\tuser:rw group:rw  all:r;\n \t\t\t# 网页页面自动索引文件\n            autoindex on;\n        }\n    }\n}\n```\n\n这样可以实现最基本的无认证，无动态目录WebDAV \n\n\n\n这篇我们编译了带实现 webdav module支持的openresy ，并且实现了最简单的WebDAV，下一篇将会通过编写lua脚本实现多用户认证，以及动态控制访问目录的功能（应该会很快写出来）\n\n\n\n\n\n","tags":["webdav","Openresty","后端","lua"]},{"title":"基础算法-二分答案","url":"/2023/03/21/基础算法-二分答案/","content":"\n## 二分答案： \n\n>解题的时候往往会考虑枚举答案然后检验枚举的值是否正确。若满足单调性，则满足使用二分法的条件。把这里的枚举换成二分，就变成了「二分答案」。[OI-WIKI](https://oi-wiki.org/basic/binary/#%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88)\n\n## 二分答案模板\n\n### 寻找 >= 的最小值\n\n```java\n    int bserach_l(int l, int r, int x)\n    {\n        while (l < r) {\n            int mid = l + ((r - l) >> 1); // 防止溢出\n            if (check(mid))\n                r = mid;\n            else\n                l = mid + 1;\n        }\n        return l;\n    }\n```\n\n### 寻找 <= 的模板\n\n```java\n    int bserach_l(int l, int r, int x)\n    {\n        while (l < r) {\n            int mid = l + ((r - l) >> 1) + 1; // 防止溢出\n            if (check(mid))\n                r = mid;\n            else\n                l = mid - 1;\n        }\n        return l;\n    }\n```\n\n### 例题 \n\n例题 [P2440 木材加工](https://www.luogu.com.cn/problem/P2440)\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        int n,k;\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        k = sc.nextInt();\n        int max = 0;\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n            max = Math.max(max,arr[i]);\n        }\n        int l = 1 , r = max;\n        int val = 0;\n        int maxVal = 0;\n        int res = 0;\n        while(l <  r){\n            int mid = l + ((r - l) >> 1);\n            val = getChunkNums(arr,mid);\n            if (val < k){\n                r = mid;\n            }else{\n                l = mid + 1;\n                if (mid >= res){\n                    res = mid;\n                    maxVal = val;\n                }\n            }\n\n        }\n        System.out.println(maxVal >= k ? res : 0);\n    }\n\n    public static int getChunkNums(int[] arr,int l){\n        int res = 0;\n        for (int i1 = 0; i1 < arr.length; i1++) {\n            res += arr[i1] / l;\n        }\n        return res;\n    }\n}\n```\n\n","tags":["算法"]},{"title":"go学习笔记和一些语法糖","url":"/2023/03/21/go学习笔记/","content":"\n\n\n### ... 的用法\n\n#### 可变参数\n\n```go\nfunc a(args ...int) int {\n\tfor _, val := range args {\n\t\t// do something\n\t}\n}\n```\n\n#### 打散slice\n\n```go\nfunc a() {\n\ts := []int{1, 2, 3}\n    b(s...)  // 这里的slice {1，2，3} 被打散为 1，2，3 传入函数b\n}\n\nfunc b(args2 ...int) {\n\tfor _, i := range args2 {\n\t\t// do something\n\t}\n}\n```\n\n### go中的继承\n\n先看一段代码\n\n```go\ntype (\n\tRouterGroup struct {\n\t\tprefix      string\n\t\tmiddlewares []HandlerFunc\n\t\tparent      *RouterGroup\n\t\tengine      *Engine\n\t}\n\n\tEngine struct {\n\t\t*RouterGroup\n\t\trouter *router\n\t\tgroups []*RouterGroup\n\t}\n)\n```\n\n可以看到上面`Engine`中包含了`*RouterGroup`这一匿名字段，`Engine` 结构体将直接继承 `RouterGroup` 中的所有字段和方法，并且不需要使用 `.prefix`、`.middlewares`、`.parent` 等字段来引用 `RouterGroup` 中的属性和方法，而可以直接使用 `Engine` 实例进行访问。\n\n### go tag\n\ntag 是一种结构化的注释方式，它可以用于给结构体字段添加元数据，例如字段的名称、类型、格式、验证规则等信息。\n\n示例如下\n\n```go\ntype Person struct {\n    Name string `json:\"name\" xml:\"name\"`\n    Age  int    `json:\"age\" xml:\"age\"`\n}\n```\n\n可以最终通过反射拿到tag的k-v信息\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\ntype Person struct {\n    Name string `json:\"name\" xml:\"name\"`\n    Age  int    `json:\"age\" xml:\"age\"`\n}\n\nfunc main() {\n    p := Person{Name: \"Alice\", Age: 25}\n    t := reflect.TypeOf(p)\n    for i := 0; i < t.NumField(); i++ {\n        field := t.Field(i)\n        tag := field.Tag\n        fmt.Printf(\"Field: %s, JSON tag: %s, XML tag: %s\\n\",\n            field.Name, tag.Get(\"json\"), tag.Get(\"xml\"))\n    }\n}\n```\n\n### cap和len\n\n`cap` 和 `len` 都是内置函数，用于获取切片、数组、map 和 channel 的长度和容量信息。\n\nslice作为一个array的引用其cap和len并不一定相等，slice的容量可以动态扩展，如果在使用 `append` 函数将元素添加到切片时长度超过了当前容量，Go 会动态分配一块更大的内存作为底层数组，并将原有数据复制到新的内存空间中，完成切片的扩容过程。如果切片的长度没有超过容量，则不会进行扩容。这个过程会导致切片的地址发生变化。可以通过对比改变前后切片的地址来判断是否扩容。\n\n### any\n\n在go1.18之后添加的新关键字 [all: rewrite `interface{}` to `any` #49884](https://github.com/golang/go/issues/49884)\n\n等同于之前的interface{} \n\n```go\ntype any interface{}\n```\n\n用法\n\n```go\nfunc a(v any) {\n\tswitch v.(type) {\n\tcase int:\n\t\tfmt.Println(\"int type val\")\n\tcase bool:\n\t\tfmt.Println(\"bool type val\")\n\t}\n}\n```\n\n","tags":["后端","go"]},{"title":"SpringBoot创建自己的Start","url":"/2023/03/05/SpringBoot创建自己的Starter/","content":"\n1. 创建SpringBoot项目\n\n   包含以下依赖\n\n```xml\n \t\t<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n\n\t     <!--自动生成meta-data-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-configuration-processor</artifactId>\n            <optional>true</optional>\n        </dependency>\n            \n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n```\n\n2. 修改`pom.xml`\n\n   修改pom.xml为对应项目名称 \n\n   starter推荐命名 xxxxx-start\n\n   ```xml\n       <groupId>com.frz</groupId>\n       <artifactId>frzApi-client-sdk</artifactId>\n       <version>0.0.2</version>\n       <name>frzApi-client-sdk</name>\n       <description>frzApi-client-sdk</description>\n   ```\n\n3. 编写`AutoConfiguration`\n\n   ```java\n   @Configuration\n   @ConfigurationProperties(\"frzapi.client\")\n   @Data\n   @ComponentScan\n   public class FrzApiClientConfig {\n       private String accessKey;\n       private String secretKey;\n       @Bean\n       public FrzApiClient frzApiClient(){\n           return new FrzApiClient(accessKey, secretKey);\n       }\n   }\n   ```\n\n   通过`ConfigurationProperties`注解能够读取application 中的配置属性\n\n4. 配置`EnableAutoConfiguration`\n\n   在`resource/META-INF`创建`spring.factories`文件,设置\n\n   ```properties\n   org.springframework.boot.autoconfigure.EnableAutoConfiguration=xxx\n   ```\n\n   > xxx为配置类Reference\n\n![目录结构](im1.png \"目录结构\")\n\n通过maven install 后即成功安装到本地maven仓库\n\n在其他项目的依赖中添加\n\n```xml\n<dependency>\n   <groupId>com.frz</groupId>\n   <artifactId>frzApi-client-sdk</artifactId>\n   <version>0.0.2</version>\n</dependency>\n```\n\n既可以正常使用\n\n\n\n","tags":["后端","sprigboot","java"]}]